# 객체지향 설계 5원칙(SOLID)
- SRP(Single Responsibility Principle)
  - 단일 책임 원칙
- OCP(Open closed Principle)
  - 개방 폐쇄 원칙
- LSP(Liskov Substitution Principle)
  - 리스코프 치환 원칙
- ISP(Interface Segregation Principle)
  - 인터페이스 분리 원칙
- DIP(Dependency Inversion Principle)
  - 의존 역전 원칙

`이 원칙들은 응집도는 높이고, 결합도는 낮추라는 고전 원칙을 객체 지향의 관점에서 재정립한 것이라고 할 수 있다.`

## 결합도와 응집도
- 좋은 소프트웨어 설계를 위해서는 결합도(coupling)는 낮추고 응집도(cohesion)는 높이는 것이 바람직하다.
- 결합도는 모듈(클래스)간의 상호 의존 정도로서 결합도가 낮으면 묘듈 간의 상호 의전성이 줄어들어 객체의 재사용이나 수정, 유지보수가 용이하다
- 응집도는 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성으로, 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져 재사용이나 기능의 수정, 유지보수가 용이하다
---
---
## SRP - 단일 책임의 원칙
- 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이여야 한다
```java
class 강아지 {
  final static boolean 수컷 = true;
  final static boolean 암컷 = false;

  void 소변보다() {
    if(this.성병 = 수컷) {
      // 한쪽 다리를 들고 소변을 본다.
    } else {
      // 뒷다리를 두 개를 굽혀 앉은 자세로 소변을 본다.
    }
  }
}
/*
강아지가 수컷이냐 암컷이냐에 따라 소변보다() 메서드에서 분기 처리가 진행되는것을 볼 수 있다.
강아지 클래스의 소변보다() 메서드가 수컷 강아지의 행위와 암컷 강아지의 행위를 모두 구현 하려고 하기에 단일 책임(행위)의 원칙을 위배한다.
단일 책임의 원칙을 적용해 코드를 리팩터링 하면... 밑 밑 밑 밑
*/
abstract class 강아지 {
  abstrack void 소변보다();
}

class 수컷강아지 extends 강아지 {
  void 소변보다() {
    // 한쪽 다리를 들고 소변을 본다.
  }
}

class 암컷강아지 extends 강아지 {
  void 소변보다() {
    // 뒷다리 두 개로 앉은 자세로 소변을 본다.
  }
}

///------------------- 다른 예시 --------------------
//남자라고 하는 클래스와 남자클래스에 의존하는 다양한 클래스가 있다고 가정

class 남자 {
  // 남자친구 역할(여자친구클래스가 의존)
  기념일챙기기()
  키스하기()
  // 아들 역할(어머니클래스가 의존)
  효도하기()
  안마하기()
  // 사원 역할(직장상사클래스가 의존)
  아부하기()
  출근하기()
  // 소대원 역할(소대장클래스가 의존)
  사격하기()
  구보하기()
} 

// 리팩터링
class 남자 {

}
class 남자친구 extends 남자 {
  기념일챙기기()
  키스하기()
}
class 아들 extends 남자 {
  효도하기()
  안마하기()
}
class 사원 extends 남자 {
  아부하기()
  출근하기()
}
class 소대원 extends 남자 {
  사격하기()
  구보하기()
}

남자 남자 = new 남자친구();

남자 남자 = new 아들();

남자 남자 = new 사원();

남자 남자 = new 소대원();
```
---
---
## OCP - 개방 폐쇄 원칙
- 소프트웨어 엔티티(클래스,모듈,함수 등)는 확장에 대해서는 여려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다
- 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.
```java
class 마티즈 {
  void 창문수동개방() {}
  void 기어수동조작() {}
}
class 소나타 {
  void 창문자동개방() {}
  void 기어자동조작() {}
}
// 이 경우 일까나...
마티즈 운전자 = new 마티즈();
운전자 = new 소나타(); // 오류
/*
운전자가 스틱차량을 타다 오토차량을 타게 되었다 운전하던 습관을 바꿔야하는가
현실세계는 운전자가 운전에 영향을 받겠지만, 객체지향세계에는 다른 해법이 있다
상위클래스 또는 인터페이스를 중간에 둠으로써 다양한 자동차가 생긴다고 해도 객체 지향 세계의 운전자는 운전 습관에 영향을 받지 않게 된다.
*/
interface 자동차 {
  창문개방()
  기어조작()
}
class 마티즈 implements 자동차 {
  창문개방()
  기어조작()
}
class 소나타 implements 자동차 {
  창문개방()
  기어조작()
}

자동차 운전자 = new 마티즈();
운전자 = new 소나타();
```
- 개방 폐쇄 원칙 아주 좋은 예) JDBC인터페이스
- oracle에서 mysql로 바꾸어도 connection설정 부분외 에는 따로 수정할 필요가 없다.
- connection부분을 별도의 설정 파일로 분리해두면 클라이언트 코드는 단 한줄도 변경할 필요가 없다
---
---
## LSP - 리스코프 치환 원칙
- 서브 타입은 언제나 자신의 기반타입(baseType)으로 교체할 수 있어야 한다.
- 하위형에서 선행 조건은 강화될 수 업삳.
- 하위형에서 후행 조건은 약화될 수 없다.
- 하위형에서 상위형의 불변 조건은 반드시 유지돼야 한다.
- `이 두개의 문장대로 구현된 프로그램이라면 이미 리스코프 치환 원칙을 잘 지키고 있다고 할 수 있다.`
  - 하위클래스 is a kind of 상위클래스
    - 하위 분류는 상위분류의 한 종류다.
  - 구현클래스 is able to 인터페이스
    - 구현 분류는 인터페이스할 수 있어야 한다.
```java
// 아버지를 상위클래스(기반타입)
// 딸을 하위클래스(서브타입)
아버지 춘향이 = new 딸(); // 딸이 아버지의 역할을 한다? 이상하다

// 동물을 상위클래스(기반타입)
// 펭귄을 하위클래스(서브타입)
동물 뽀로로 = new 펭귄(); // 논리적인 흠이 없다 리스코프 치환 원칙 만족
```
---
---
## ISP - 인터페이스 분리 원칙
- 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다.
```java
class 남자 implements 남자친구, 사원, 아들, 소대원 {
  기념일챙기기()
  키스하기()

  효도하기()
  안마하기()

  아부하기()
  출근하기()

  사격하기()
  구보하기()
}
interface 남자친구 {
  기념일챙기기()
  키스하기()
}
interface 아들 {
  효도하기()
  안마하기()
}
interface 사원 {
  아부하기()
  출근하기()
}
interface 소대원 {
  사격하기()
  구보하기()
}
// 여자친구를 만날 땐 남자친구 역할만 할 수 있게 인터페이스로 제한
남자 남자 = new 남자친구();
// 어머니와 있을 때는 아들 인터페이스로 제한
남자 남자 = new 아들();
// 직장 상사 앞에서는 사원 인터페이스로 제한
남자 남자 = new 사원();
// 소대장 앞에서는 소대원 인터페이스로 제한
남자 남자 = new 소대원();

// 근데 여자친구랑 엄마를 같이 만났을 땐 어떻게 하죠?...
```
- 결론적으로 단일책임원칙(SRP)과 인터페이스분할원칙(ISP)은 같은 문제에 대한 두 가지 다른 해결책이라 볼 수 있다
- 프로젝트 요구사항과 설계자의 취향에 따라 단일책임원칙 이나 인터페이스분할원칙 중 하나를 선택해서 설계할 수 있다.
- 하지만 특별한 경우가 아니라면 단일책인원칙을 적용하는것이 더 좋은 해결책이라고 하네요?...
---
---
## DIC - 의존 역전 원칙
- 고차원 모듈은 저차원 모듈에 의존하면 안 된다.
  - 이 두 모듈 모두 다른 추상화 된것에 의존해야 한다.
- 추상화된 것은 구체적인 것에 의존하면 안된다.
  - 구체적인 것이 추상화된 것에 의존해야 한다.
- 자주 변경되는 구체(Concrete)클래스에 의존하지 마라
  - 자신보다 변하기 쉬운것에 의존하지 마라
- `상위 클래스일수록, 인터페이스일수록, 추상 클래스일수록 변하지 않을 가능성이 높기에 하위클래스, 구체클래스가 아닌 상위클래스,인터페이스,추상클래스를 통해 의존하라는 것이 바로 의존 역전 원칙`
```java
class Car {
  SnowTire snowTire = new SnowTire;
}
/*
자동차가 스노우 타이어에 의존하고 있다
그런데 자동차는 한 번 사면 몇 년은 타야 하는데 스노우 타이어는 계절이 바뀌면 일반 타이어로 교체 해야 한다.
이런 경우 스노우 타이어를 일반 타이어로 교체할 때 자동차는 그 영향에 노출돼 있음을 알 수 있다
리팩터링 해보자(책의 설명이 부족해 직접 만들어 봤다;;)
*/
class 자동차 {
  Tire tire;

  void setTire(Tire tire) { // Tire인터페이스를 구현한 구현클래스만 들어올 수 있음
  this.tire = tire;
  }
}

interface Tire {}
class SnowTire implements Tire {}
class BasicTire implements Tire {}
class WideTire implements Tire {}

Car theCar = new Car();
theCar.setTire(new SnowTire); // 스노우 타이어 장착
theCar.setTire(new BasicTire); // 기본타이어로 교체

// 이 방식 상속도 가능할듯
```