# 디자인패턴
요리 | 객체 지향 프로그래밍(Object Oriented Programming)
---|---
요리도구 | 4대 원칙(캡슐화,상속,추상화,다형성)
요리도구 사용법 | 설계원칙(SOLID)
레시피 | 디자인패턴
- 디자인패턴은 객체지향의 특성 중 상속(extends), 인터페이스(interface/implements),합성(객체를 속성으로 사용)을 이용한다.
- 이 세가지 방식 외에 다른 방식은 없다.
- 그러다 보니 여러 디자인패턴이 비슷해 보일 수 있다.
---
---
## 어댑터 패턴(Adapter Pattern)
- 어댑터를 번역하면 변환기(converter)라고 할 수 있다.
- 변환기의 역할은 서로 다른 두 인터페이스 사이에 통신이 가능하게 하는 것이다.(휴대폰 전원콘센트 사이 충전기같은 느낌)
- 어댑터패턴은 개방폐쇄 원칙을 활용한 설계 패넡이라고 할 수 있다.
```java
// 어댑터 패턴이 적용되지 않은 코드

public class ServiceA {
    void runServiceA() {
        System.out.println("ServiceA");
    }
}

public class ServiceB {
    void runServiceB {
        System.out.println("ServiceB");
    }
}

public class ClientWithNoAdapter {
    public static void main(String[] args) {
        ServiceA sa1 = new ServiceA();
        ServiceB sb1 = new ServiceB();

        sa1.runServiceA(); // ServiceA 출력
        sb1.runServiceB(); // ServiceB 출력
    }
}

// 어댑터 패턴 리팩터링

public class ServiceA {
    ServiceA sa1 = new ServiceA();

    void runServiceA {
        System.out.prinltn("ServiceA");
    }
    
    void runService {
        sa1.runServiceA();
    }
}

public class ServiceB {
    ServiceB sb1 = new ServiceB();

    void runServiceB() {
        System.out.println("ServiceB");
    }

    void runService {
        sb1.runServiceB();
    }
}

public class ClientWithAdapter {
    public static void main(String[] args) {
        ServiceA asa1 = new ServiceA();
        ServiceB asb1 = new ServiceB();

        asa1.runService(); // ServiceA 출력
        asb1.runService(); // ServiceB 출력
    }
}
/*
어댑터패턴은 합성, 즉 객체를 속성으로 만들어서 참조하는 디자인 패턴으로, 한 문장으로 정리하면 다음과 같다.

"호출당하는 쪽의 메서드를 호출하는 쪽의 코드에 대응하도록 중간에 변환기를 통해 호출하는 패턴"
*/
```
---
---
## 프록시 패턴(Proxy Pattern)
- 프록시는 대리자, 대변인이라는 뜻을 가진 단어다.
- 다른 누군가를 대신해 그 역할을 수행하는 존재를 말한다.
```java
// 프론시 패턴 사용 안한 코드
class Service {
    public String runSomething() {
        return "서비스짱";
    }
}

class ClientWithNoProxy {
    //프록시를 이용하지 않은 호출
    Service service = new Service();
    System.out.println(service.runSomething());
}


// 프록시패턴 리팩터링

interface Service {
    public String runSomething();
}

class ServiceImpl implements Service {
    public String runSomething() {
        return "서비스짱";
    }
}

class Proxy implements Service{
    Service service;

    public String runSomething() {
        System.out.println("호출에 대한 흐름 제어가 주목적, 반환 결과 그대로 전달");

        service = new ServiceImpl();
        
        return service.runSomething();
    }
}

public class ClientWithProxy {
    public static void main(String[] args) {
        // 프록시를 이용한 호출
        Service proxy = new Proxy(); 
        System.out.println(proxy.runSomething());
    }
}
/*
- 대리자는 실제 서비스와 같은 이름의 메서드를 구현한다. 이때 인터페이스를 사용한다.
- 대리자는 실제 서비스에 대한 잠조 변수를 갖는다(합성)
- 대리자는 실제 서브시의 같은 이름을 가진 메서드를 호출하고 그 값을 클라이언트에게 되돌려준다.
- 대리자는 실제 서비스의 메서드 호출 전후에 별도의 로직을 수행할 수도 있다.

"제어 흐름을 조정하기 위한 목적으로 중간에 대리자를 두는 패턴"

이 예제에서 살펴본 프록시패턴은 개방폐쇄원칙과 의존역전원칙이 적용된 설계 패턴이다
*/
```
---
---
## 데코레이터 패턴(Decorator pattern)
- 데코레이터는 도장/도배업자를 의미. 여기서는 장식자라는 뜻을 가진다.
- 데코레이터는 프록시패턴과 구현 방법이 같다.
- 다만 프록시패턴은 클라이언트가 최종적으로 돌벼받는 반환값을 조작하지 않고 그대로 전달하는 반면 데코레이터 패턴은 클라이언트가 받는 반환값에 장식을 덧입힌다.
- 프록시패턴
  - 제어의 흐름을 변경하거나 별도의 로직 처리를 목적으로 한다. 클라이언트가 받는 반환값을 특별한 경우가 아니면 변경하지 않는다.
- 데코레이터패턴
  - 클라이언트가 받는 반환값에 장식을 더한다.
```java
// 데코레이터 패턴
interface Service {
    public String runSomething();
}

class ServiceImpl implements Service {
    public String runSomething() {
        return "서비스짱";
    }
}

class Decorator implements Service{
    Service service;

    public String runSomething() {
        System.out.println("호출에 대한 장식 주목적, 클라이언트에게 반환 결과에 장식을 더하여 전달");

        service = new ServiceImpl();
        
        return "정말" + service.runSomething();
    }
}

public class ClientWithProxy {
    public static void main(String[] args) {
        
        Service decorator = new Decorator(); 
        System.out.println(proxy.runSomething());
    }
}
/*
- 장식자는 실제 서비스와 같은 이름의 메서드를 구현한다. 이때 인터페이스를 사용한다.
- 장식자는 실제 서비스에 대한 참조 변수를 갖는다(합성)
- 장식자는 실제 서비스와 같은 이름을 가진 메서드를 호출하고, 그 반환값에 장식을 더해 클라이언트에게 돌려준다.
- 장식자는 실제 서비스의 메서드 호출 전후에 별도의 로직을 수행할 수도 있다.

"메서드 호출의 반환값에 변화를 주기 위해 중간에 장식자를 두는 패턴"

데코레이터 패턴도 개방폐쇄원칙 과 의족역전원칙이 적용된 설계 패턴
*/
```
---
---
## 싱글턴 패턴(Singleton Pattern)
- 싱글턴패턴이란 인스턴스 하나만 만들어 사용하기 위한 패턴이다
- 커넥션풀, 스레드풀, 디바이스설정 객체 등과 같은 경우 인스턴스를 여러개 만들게 되면 불필요한 자원을 하용하게 되고, 또 프로그램이 예상치 못한 결과를 낳을 수 있다.
- 1. new를 실행할 수 없도록 생성자에 private 접근 제어자를 지정한다.
- 2. 유일한 단일 객체를 반환할 수 있는 정적 메서드가 필요하다.
- 3. 유일한 단일 객체를 참조할 정적 참조 변수가 필요하다.
```java

```
